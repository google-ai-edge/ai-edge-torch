# Copyright 2024 The AI Edge Torch Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ==============================================================================

"""Contains utility functions to test TFLite models exported from PyTorch."""

from collections.abc import Callable

from ai_edge_torch import model
import numpy as np
import torch
from torch.utils import _pytree as pytree


# Utility to flatten the order to make it deterministic.
# Ordering is done in left-to-right depth-first tree traversal.
def _flatten(data):
  out, _ = pytree.tree_flatten(data)
  return out


# Convert a Torch Tensor to a numpy array
def _torch_tensors_to_np(*argv):
  """Converts a Torch Tensor to a numpy array.

  Args:
    *argv: A list of torch.tensor or a single torch.tensor.

  Returns:
    A list of numpy array or a single numpy array.
  """
  if len(argv) > 1:
    data = list(argv)
  else:
    data = argv[0]

  if isinstance(data, torch.Tensor):
    return data.to("cpu").detach().numpy()

  elif isinstance(data, (list, tuple)):
    out = []
    for di in data:
      out.append(_torch_tensors_to_np(di))
    return out

  elif isinstance(data, dict):
    out = {}
    for ni, di in data.items():
      out[ni] = _torch_tensors_to_np(di)
    return out

  else:
    raise ValueError("Unsupported torch.tensor type.")


def compare_tflite_torch(
    edge_model: model.Model,
    torch_eval_func: Callable,
    args=None,
    kwargs=None,
    *,
    num_valid_inputs: int = 1,
    signature_name: str = None,
    atol: float = 1e-5,
    rtol: float = 1e-5
):
  """Compares torch models and TFLite models.

  Args:
    edge_model: Serialized ai_edge_torch.model.Model object.
    torch_eval_func: Callable function to evaluate torch model.
    args: torch.tensor array or a callable to generate a torch.tensor array with
      random data, to pass into models during inference. (default None).
    kwargs: dict of str to torch.tensor, or a callable to generate such.
    num_valid_inputs: Defines the number of times the random inputs will be
      generated (if a callable is provided for input_data).
    signature_name: If provided, specifies the name for the signature of the
      edge_model to run. Calls the default signature if not provided.
    atol: Absolute tolerance (see `numpy.allclose`)
    rtol: Relative tolerance (see `numpy.allclose`)
  """
  # Convert the input data and the output data into an array.
  # output data here is generated by running the `torch_eval_func` and
  # is considered to act as golden data for verification purposes

  # The supplied model_def.forward_args() will be executed num_valid_inputs
  # times to generate num_valid_inputs random inputs.
  torch_inputs = [
      (
          (args() if callable(args) else args) or tuple(),
          (kwargs() if callable(kwargs) else kwargs) or {},
      )
      for _ in range(num_valid_inputs)
  ]
  torch_outputs = [
      torch_eval_func(*args, **kwargs) for args, kwargs in torch_inputs
  ]
  np_inputs = [
      (_torch_tensors_to_np(args), _torch_tensors_to_np(kwargs))
      for args, kwargs in torch_inputs
  ]
  np_outputs = [_torch_tensors_to_np(_flatten(ys)) for ys in torch_outputs]

  # Define inline utility function used throughout the function.
  def equal_fn(actual, expected):
    return np.allclose(actual, expected, atol=atol, rtol=rtol)

  def get_edge_output(inputs):
    args, kwargs = inputs
    if signature_name is None:
      return _flatten(edge_model(*args, **kwargs))
    else:
      return _flatten(
          edge_model(*args, **kwargs, signature_name=signature_name)
      )

  for idx, np_input in enumerate(np_inputs):
    output = get_edge_output(np_input)
    golden_output = np_outputs[idx]
    is_output_len_eq = len(golden_output) == len(output)

    output = [v.astype(np.float32) for v in output]
    golden_output = [v.astype(np.float32) for v in golden_output]

    # Append the results of each invoke to a function-global variable
    # used to store the comparison final results
    is_equal = is_output_len_eq and all([
        equal_fn(out, golden_out)
        for out, golden_out in zip(output, golden_output)
    ])
    if not is_equal:
      return False

  return True
